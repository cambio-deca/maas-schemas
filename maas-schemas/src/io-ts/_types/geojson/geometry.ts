/*

GeoJSON Geometry
GeoJSON geometry, forked from https://github.com/fge/sample-json-schemas/ under BSD license

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export type DefinedC = {} & DefinedType;
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'https://schemas.maas.global/geojson/geometry.json';

// Position
// A single position
export type Position = t.Branded<[number, number], PositionBrand>;
export type PositionC = t.BrandC<t.TupleC<[t.NumberC, t.NumberC]>, PositionBrand>;
export const Position: PositionC = t.brand(
  t.tuple([t.number, t.number]),
  (x): x is t.Branded<[number, number], PositionBrand> =>
    Array.isArray(x) === false || x.length >= 2,
  'Position',
);
export type PositionBrand = {
  readonly Position: unique symbol;
};

// PositionArray
// An array of positions
export type PositionArray = t.Branded<Array<Position>, PositionArrayBrand>;
export type PositionArrayC = t.BrandC<t.ArrayC<typeof Position>, PositionArrayBrand>;
export const PositionArray: PositionArrayC = t.brand(
  t.array(Position),
  (x): x is t.Branded<Array<Position>, PositionArrayBrand> => true,
  'PositionArray',
);
export type PositionArrayBrand = {
  readonly PositionArray: unique symbol;
};

// LineString
// An array of two or more positions
export type LineString = t.Branded<PositionArray & unknown, LineStringBrand>;
export type LineStringC = t.BrandC<
  t.IntersectionC<[typeof PositionArray, t.UnknownC]>,
  LineStringBrand
>;
export const LineString: LineStringC = t.brand(
  t.intersection([PositionArray, t.unknown]),
  (x): x is t.Branded<PositionArray & unknown, LineStringBrand> => true,
  'LineString',
);
export type LineStringBrand = {
  readonly LineString: unique symbol;
};

// LinearRing
// An array of four positions where the first equals the last
export type LinearRing = t.Branded<PositionArray & unknown, LinearRingBrand>;
export type LinearRingC = t.BrandC<
  t.IntersectionC<[typeof PositionArray, t.UnknownC]>,
  LinearRingBrand
>;
export const LinearRing: LinearRingC = t.brand(
  t.intersection([PositionArray, t.unknown]),
  (x): x is t.Branded<PositionArray & unknown, LinearRingBrand> => true,
  'LinearRing',
);
export type LinearRingBrand = {
  readonly LinearRing: unique symbol;
};

// Polygon
// An array of linear rings
export type Polygon = t.Branded<Array<LinearRing>, PolygonBrand>;
export type PolygonC = t.BrandC<t.ArrayC<typeof LinearRing>, PolygonBrand>;
export const Polygon: PolygonC = t.brand(
  t.array(LinearRing),
  (x): x is t.Branded<Array<LinearRing>, PolygonBrand> => true,
  'Polygon',
);
export type PolygonBrand = {
  readonly Polygon: unique symbol;
};

// Geometry
// The default export. More information at the top.
export type Geometry = t.Branded<
  Record<string, unknown> &
    Record<string, unknown> & {
      type: Defined;
      coordinates: Defined;
    } & (
      | ({
          type?: 'Point';
          coordinates?: Position;
        } & Record<string, unknown>)
      | ({
          type?: 'MultiPoint';
          coordinates?: PositionArray;
        } & Record<string, unknown>)
      | ({
          type?: 'LineString';
          coordinates?: LineString;
        } & Record<string, unknown>)
      | ({
          type?: 'MultiLineString';
          coordinates?: Array<LineString>;
        } & Record<string, unknown>)
      | ({
          type?: 'Polygon';
          coordinates?: Polygon;
        } & Record<string, unknown>)
      | ({
          type?: 'MultiPolygon';
          coordinates?: Array<Polygon>;
        } & Record<string, unknown>)
    ),
  GeometryBrand
>;
export type GeometryC = t.BrandC<
  t.IntersectionC<
    [
      t.UnknownRecordC,
      t.RecordC<t.StringC, t.UnknownC>,
      t.TypeC<{
        type: typeof Defined;
        coordinates: typeof Defined;
      }>,
      t.UnionC<
        [
          t.IntersectionC<
            [
              t.PartialC<{
                type: t.LiteralC<'Point'>;
                coordinates: typeof Position;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
          t.IntersectionC<
            [
              t.PartialC<{
                type: t.LiteralC<'MultiPoint'>;
                coordinates: typeof PositionArray;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
          t.IntersectionC<
            [
              t.PartialC<{
                type: t.LiteralC<'LineString'>;
                coordinates: typeof LineString;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
          t.IntersectionC<
            [
              t.PartialC<{
                type: t.LiteralC<'MultiLineString'>;
                coordinates: t.ArrayC<typeof LineString>;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
          t.IntersectionC<
            [
              t.PartialC<{
                type: t.LiteralC<'Polygon'>;
                coordinates: typeof Polygon;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
          t.IntersectionC<
            [
              t.PartialC<{
                type: t.LiteralC<'MultiPolygon'>;
                coordinates: t.ArrayC<typeof Polygon>;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
        ]
      >,
    ]
  >,
  GeometryBrand
>;
export const Geometry: GeometryC = t.brand(
  t.intersection([
    t.UnknownRecord,
    t.record(t.string, t.unknown),
    t.type({
      type: Defined,
      coordinates: Defined,
    }),
    t.union([
      t.intersection([
        t.partial({
          type: t.literal('Point'),
          coordinates: Position,
        }),
        t.record(t.string, t.unknown),
      ]),
      t.intersection([
        t.partial({
          type: t.literal('MultiPoint'),
          coordinates: PositionArray,
        }),
        t.record(t.string, t.unknown),
      ]),
      t.intersection([
        t.partial({
          type: t.literal('LineString'),
          coordinates: LineString,
        }),
        t.record(t.string, t.unknown),
      ]),
      t.intersection([
        t.partial({
          type: t.literal('MultiLineString'),
          coordinates: t.array(LineString),
        }),
        t.record(t.string, t.unknown),
      ]),
      t.intersection([
        t.partial({
          type: t.literal('Polygon'),
          coordinates: Polygon,
        }),
        t.record(t.string, t.unknown),
      ]),
      t.intersection([
        t.partial({
          type: t.literal('MultiPolygon'),
          coordinates: t.array(Polygon),
        }),
        t.record(t.string, t.unknown),
      ]),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    Record<string, unknown> &
      Record<string, unknown> & {
        type: Defined;
        coordinates: Defined;
      } & (
        | ({
            type?: 'Point';
            coordinates?: Position;
          } & Record<string, unknown>)
        | ({
            type?: 'MultiPoint';
            coordinates?: PositionArray;
          } & Record<string, unknown>)
        | ({
            type?: 'LineString';
            coordinates?: LineString;
          } & Record<string, unknown>)
        | ({
            type?: 'MultiLineString';
            coordinates?: Array<LineString>;
          } & Record<string, unknown>)
        | ({
            type?: 'Polygon';
            coordinates?: Polygon;
          } & Record<string, unknown>)
        | ({
            type?: 'MultiPolygon';
            coordinates?: Array<Polygon>;
          } & Record<string, unknown>)
      ),
    GeometryBrand
  > => true,
  'Geometry',
);
export type GeometryBrand = {
  readonly Geometry: unique symbol;
};

export default Geometry;

// Success
