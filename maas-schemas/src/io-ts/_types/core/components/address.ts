/*

undefined
MaaS schema for address related information

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import * as t from 'io-ts';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

import * as Common_ffba_ from './common';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export type DefinedC = {} & DefinedType;
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'https://schemas.maas.global/core/components/address.json';

// ComponentAddress
// Encoded address components. Check the regexr examples. Check https://regexr.com/4ofcq. In streetNumber, there are 2 dashes - they have 2 different unicodes, do not remove
export type ComponentAddress = t.Branded<string, ComponentAddressBrand>;
export type ComponentAddressC = t.BrandC<t.StringC, ComponentAddressBrand>;
export const ComponentAddress: ComponentAddressC = t.brand(
  t.string,
  (x): x is t.Branded<string, ComponentAddressBrand> =>
    typeof x !== 'string' ||
    x.match(
      RegExp(
        "(id:(\\p{L}|\\p{N}|[%-])+\\|?)|(streetName:(\\p{L}|\\p{N}|-|\\/| (?=\\p{L}|&|\\p{N})|[#.,;:'&¬∞‚Äô])+\\|?)|(city:(\\p{L}|['-]| (?=\\p{L}))+\\|?)|(state:(\\p{L}|[-]| (?=\\p{L}))+\\|?)|(zipCode:(\\p{L}|\\p{N}|-)+\\|?)|(country:(\\p{L}| (?=\\p{L}))+)\\|?|(streetNumber:(\\p{L}|\\p{N}|-|-|\\/)+)\\|?|(ward:(\\p{L}|\\p{N}|-|[']| (?=\\p{L}|\\p{N}))+)\\|?|(district:(\\p{L}|\\p{N}|-|[']| (?=\\p{L}|\\p{N}))+)\\|?",
        'u',
      ),
    ) !== null,
  'ComponentAddress',
);
export type ComponentAddressBrand = {
  readonly ComponentAddress: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(ComponentAddress)).decodeSync(examplesComponentAddress) // => examplesComponentAddress */
export const examplesComponentAddress: NonEmptyArray<ComponentAddress> = [
  'state:T≈çky≈ç-to|district:Kanda Nishikich≈ç 3-ch≈çme|streetNumber:4-„Éë„É¨„Çπ„ÉÜ„É•„Éá„Ç£„Ç™Âæ°Ëå∂„ÉéÊ∞¥ÈßøÊ≤≥Âè∞ÂèÇÁï™È§®|zipCode:101-0054|city:Chiyoda-City|country:Japan',
  "id:pe--Aigle--whosonfirst%3Alocality%3A101853849|streetName:Tarkk'ampuj√§nk√§tu|city:Helsinki|country:Finland|state:Uusimaa|streetNumber:1|zipCode:00100|district:Tapiola",
  "streetName:H√§meentie T√∂√∂l√∂ntori L√§hettil√§√§ntie Tarkk'ampuj√§nk√§tu",
  'streetName:Br√§dg√•rdsgatan',
  'streetName:≈ª√≥≈Çkiewskiego',
  'streetName:√òster All√©',
  'streetName:ÿ¥ÿßÿ±ÿπ ÿ≠ŸÖÿØÿßŸÜ ÿ®ŸÜ ŸÖÿ≠ŸÖÿØ',
  'streetName:Karl-Marx-Stra√üe',
  'streetName:K√º√ß√ºk Ayasofya|city:ƒ∞stanbul|district:Fatih',
  'streetName:11 Avenue d‚ÄôOstende',
  'streetName:K√º√ß√ºk Ayasofya, K√º√ß√ºk Ayasofya Cami Sk.',
  "streetName:Kasumi'gaseki",
  "streetName:St Martin's Lane",
  'country:√Öland',
  'country:Puerto Rico',
  'country:fran√ßais',
  'country:skandinavisk',
  'streetNumber:1-1',
  'streetNumber:1/2-d2',
  'country:Finland|state:Uusimaa|city:Helsinki|zipCode:00100|streetName:Ludviginkatu|streetNumber:6',
  'city:Helsinki|state:Uusimaa|country:Finland|zipCode:00100|streetName:Ludviginkatu|streetNumber:6',
  'city:Helsinki|country:Finland|zipCode:00100|streetName:Ludviginkatu|streetNumber:6',
  'country:New Zealand|state:Bay of Plenty|city:White Pine Bush|zipCode:3191|streetName:White Pine Bush Road|streetNumber:479',
  "country:C√¥te d'Ivoire|city:Abidjan|zipCode:01 BP2581|streetName:Cocody Quartier Ambassades Impasse du Belier|streetNumber:58",
  "country:A√§√∂ŸÖÊ≠¶–∫–≤'|state:A√§√∂ŸÖÊ≠¶–∫–≤.-`''¬¥`|city:A√§√∂ŸÖÊ≠¶–∫–≤.-`''¬¥`|zipCode:3191|streetName:A√§√∂ŸÖÊ≠¶–∫–≤.-`''¬¥`|streetNumber:479",
  'city:Lontoo|streetNumber:2|streetName:Charrington Street|zipCode:NW1|country:Yhdistynyt kuningaskunta',
  "country:UK|city:London|zipCode:NW8 7HA|streetName:St John's Wood Road|streetNumber:28",
  'country:UK|city:London|zipCode:SE1 9DT|streetName:New Globe Walk|streetNumber:21',
] as unknown as NonEmptyArray<ComponentAddress>;
// NEGATIVE Test Case: emoji
/** require('io-ts-validator').validator(ComponentAddress).decodeEither("üí©")._tag // => 'Left' */

// PlaceId
// Upstream API placeId
export type PlaceId = t.Branded<string, PlaceIdBrand>;
export type PlaceIdC = t.BrandC<t.StringC, PlaceIdBrand>;
export const PlaceId: PlaceIdC = t.brand(
  t.string,
  (x): x is t.Branded<string, PlaceIdBrand> =>
    (typeof x !== 'string' || x.match(RegExp('^\\p{L}+$', 'u')) !== null) &&
    (typeof x !== 'string' || x.length <= 64),
  'PlaceId',
);
export type PlaceIdBrand = {
  readonly PlaceId: unique symbol;
};

// StreetName
// The purpose of this remains a mystery
export type StreetName = t.Branded<string, StreetNameBrand>;
export type StreetNameC = t.BrandC<t.StringC, StreetNameBrand>;
export const StreetName: StreetNameC = t.brand(
  t.string,
  (x): x is t.Branded<string, StreetNameBrand> => typeof x !== 'string' || x.length >= 1,
  'StreetName',
);
export type StreetNameBrand = {
  readonly StreetName: unique symbol;
};

// City
// Alphabetic city name
export type City = t.Branded<string, CityBrand>;
export type CityC = t.BrandC<t.StringC, CityBrand>;
export const City: CityC = t.brand(
  t.string,
  (x): x is t.Branded<string, CityBrand> => typeof x !== 'string' || x.length >= 1,
  'City',
);
export type CityBrand = {
  readonly City: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(City)).decodeSync(examplesCity) // => examplesCity */
export const examplesCity: NonEmptyArray<City> = [
  'Helsinki',
  'Âåó‰∫¨',
  '„ÅÇ„Åç„ÇãÈáéÂ∏Ç',
  '–ú–æ—Å–∫–≤–∞',
] as unknown as NonEmptyArray<City>;
// NEGATIVE Test Case: empty string
/** require('io-ts-validator').validator(City).decodeEither("")._tag // => 'Left' */

// State
// Alphabetic state name
export type State = t.Branded<string, StateBrand>;
export type StateC = t.BrandC<t.StringC, StateBrand>;
export const State: StateC = t.brand(
  t.string,
  (x): x is t.Branded<string, StateBrand> =>
    (typeof x !== 'string' || x.match(RegExp("^(?:\\p{L}|\\s|')+$", 'u')) !== null) &&
    (typeof x !== 'string' || x.length <= 64),
  'State',
);
export type StateBrand = {
  readonly State: unique symbol;
};

// ZipCode
// Numeric zip code, see https://en.wikipedia.org/wiki/Postal_code
export type ZipCode = t.Branded<string, ZipCodeBrand>;
export type ZipCodeC = t.BrandC<t.StringC, ZipCodeBrand>;
export const ZipCode: ZipCodeC = t.brand(
  t.string,
  (x): x is t.Branded<string, ZipCodeBrand> =>
    (typeof x !== 'string' || x.length >= 2) && (typeof x !== 'string' || x.length <= 64),
  'ZipCode',
);
export type ZipCodeBrand = {
  readonly ZipCode: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(ZipCode)).decodeSync(examplesZipCode) // => examplesZipCode */
export const examplesZipCode: NonEmptyArray<ZipCode> = [
  '00100',
  'TW6 2GA',
  'K1A 0B1',
  '102600',
  '90210',
  'N1C',
  '3137BH',
] as unknown as NonEmptyArray<ZipCode>;
// NEGATIVE Test Case: empty string
/** require('io-ts-validator').validator(ZipCode).decodeEither("")._tag // => 'Left' */
// NEGATIVE Test Case: single ascii character
/** require('io-ts-validator').validator(ZipCode).decodeEither("a")._tag // => 'Left' */

// Country
// ISO 3166-1 alpha-2 country code, see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
export type Country = t.Branded<string, CountryBrand>;
export type CountryC = t.BrandC<t.StringC, CountryBrand>;
export const Country: CountryC = t.brand(
  t.string,
  (x): x is t.Branded<string, CountryBrand> =>
    typeof x !== 'string' || x.match(RegExp('^[A-Z]{2,2}$', 'u')) !== null,
  'Country',
);
export type CountryBrand = {
  readonly Country: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(Country)).decodeSync(examplesCountry) // => examplesCountry */
export const examplesCountry: NonEmptyArray<Country> = [
  'FI',
  'GB',
] as unknown as NonEmptyArray<Country>;
// NEGATIVE Test Case: empty string
/** require('io-ts-validator').validator(Country).decodeEither("")._tag // => 'Left' */
// NEGATIVE Test Case: emoji
/** require('io-ts-validator').validator(Country).decodeEither("üí©")._tag // => 'Left' */
// NEGATIVE Test Case: lower case alpha-2 country code
/** require('io-ts-validator').validator(Country).decodeEither("fi")._tag // => 'Left' */
// NEGATIVE Test Case: alpha-3 country code
/** require('io-ts-validator').validator(Country).decodeEither("FIN")._tag // => 'Left' */

// StreetNumber
// The purpose of this remains a mystery
export type StreetNumber = t.Branded<string, StreetNumberBrand>;
export type StreetNumberC = t.BrandC<t.StringC, StreetNumberBrand>;
export const StreetNumber: StreetNumberC = t.brand(
  t.string,
  (x): x is t.Branded<string, StreetNumberBrand> =>
    typeof x !== 'string' || x.length >= 1,
  'StreetNumber',
);
export type StreetNumberBrand = {
  readonly StreetNumber: unique symbol;
};

// Ward
// The purpose of this remains a mystery
export type Ward = t.Branded<string, WardBrand>;
export type WardC = t.BrandC<t.StringC, WardBrand>;
export const Ward: WardC = t.brand(
  t.string,
  (x): x is t.Branded<string, WardBrand> => typeof x !== 'string' || x.length >= 1,
  'Ward',
);
export type WardBrand = {
  readonly Ward: unique symbol;
};

// District
// The purpose of this remains a mystery
export type District = t.Branded<string, DistrictBrand>;
export type DistrictC = t.BrandC<t.StringC, DistrictBrand>;
export const District: DistrictC = t.brand(
  t.string,
  (x): x is t.Branded<string, DistrictBrand> => typeof x !== 'string' || x.length >= 1,
  'District',
);
export type DistrictBrand = {
  readonly District: unique symbol;
};

// ComponentAddressObject
// The purpose of this remains a mystery
export type ComponentAddressObject = t.Branded<
  {
    id?: PlaceId;
    streetName?: StreetName;
    city?: City;
    state?: State;
    zipCode?: ZipCode;
    country?: Country;
    streetNumber?: StreetNumber;
    ward?: Ward;
    district?: District;
  } & {
    streetName: Defined;
    streetNumber: Defined;
    zipCode: Defined;
  },
  ComponentAddressObjectBrand
>;
export type ComponentAddressObjectC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        id: typeof PlaceId;
        streetName: typeof StreetName;
        city: typeof City;
        state: typeof State;
        zipCode: typeof ZipCode;
        country: typeof Country;
        streetNumber: typeof StreetNumber;
        ward: typeof Ward;
        district: typeof District;
      }>,
      t.TypeC<{
        streetName: typeof Defined;
        streetNumber: typeof Defined;
        zipCode: typeof Defined;
      }>,
    ]
  >,
  ComponentAddressObjectBrand
>;
export const ComponentAddressObject: ComponentAddressObjectC = t.brand(
  t.intersection([
    t.partial({
      id: PlaceId,
      streetName: StreetName,
      city: City,
      state: State,
      zipCode: ZipCode,
      country: Country,
      streetNumber: StreetNumber,
      ward: Ward,
      district: District,
    }),
    t.type({
      streetName: Defined,
      streetNumber: Defined,
      zipCode: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      id?: PlaceId;
      streetName?: StreetName;
      city?: City;
      state?: State;
      zipCode?: ZipCode;
      country?: Country;
      streetNumber?: StreetNumber;
      ward?: Ward;
      district?: District;
    } & {
      streetName: Defined;
      streetNumber: Defined;
      zipCode: Defined;
    },
    ComponentAddressObjectBrand
  > => true,
  'ComponentAddressObject',
);
export type ComponentAddressObjectBrand = {
  readonly ComponentAddressObject: unique symbol;
};

// PlaceName
// Place name (given in autocomplete)
export type PlaceName = t.Branded<string, PlaceNameBrand>;
export type PlaceNameC = t.BrandC<t.StringC, PlaceNameBrand>;
export const PlaceName: PlaceNameC = t.brand(
  t.string,
  (x): x is t.Branded<string, PlaceNameBrand> => typeof x !== 'string' || x.length >= 1,
  'PlaceName',
);
export type PlaceNameBrand = {
  readonly PlaceName: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(PlaceName)).decodeSync(examplesPlaceName) // => examplesPlaceName */
export const examplesPlaceName: NonEmptyArray<PlaceName> = [
  'Kallan & Co Oy, Simonsgatan, Helsinki',
  'Erenk√∂y Mahallesi, √áoban Yƒ±ldƒ±zƒ± Sk. No:4, 34738 Kadƒ±k√∂y/ƒ∞stanbul, Turkki',
  '5-2 4-2 „Çø„Ç§„É†„Ç∫„Çπ„ÇØ„Ç®„Ç¢„Éì„É´ Takashimaya Shinjuku',
  'Ê≠¶‰æØÂå∫ÈÄöÁ•†Ë∑Ø39Âè∑-Ê±üÂüéËä±2Ê•º (Êò•Ê±üËä±ÊúàÂ§úÂØπÈù¢)',
  "28 St John's Wood Road, London",
  "Shakespeare's Globe",
  'Tarkk¬¥ampujankatu',
  "'s-Gravesandestraat 55",
] as unknown as NonEmptyArray<PlaceName>;
// NEGATIVE Test Case: empty string
/** require('io-ts-validator').validator(PlaceName).decodeEither("")._tag // => 'Left' */

// FirstName
// First name of the customer (e.g. John)
export type FirstName = t.Branded<Common_ffba_.PersonalName, FirstNameBrand>;
export type FirstNameC = t.BrandC<typeof Common_ffba_.PersonalName, FirstNameBrand>;
export const FirstName: FirstNameC = t.brand(
  Common_ffba_.PersonalName,
  (x): x is t.Branded<Common_ffba_.PersonalName, FirstNameBrand> => true,
  'FirstName',
);
export type FirstNameBrand = {
  readonly FirstName: unique symbol;
};

// LastName
// Last name of the customer (e.g. Doe)
export type LastName = t.Branded<Common_ffba_.PersonalName, LastNameBrand>;
export type LastNameC = t.BrandC<typeof Common_ffba_.PersonalName, LastNameBrand>;
export const LastName: LastNameC = t.brand(
  Common_ffba_.PersonalName,
  (x): x is t.Branded<Common_ffba_.PersonalName, LastNameBrand> => true,
  'LastName',
);
export type LastNameBrand = {
  readonly LastName: unique symbol;
};

// Phone
// ITU-T E.164 phone number
export type Phone = t.Branded<Common_ffba_.Phone, PhoneBrand>;
export type PhoneC = t.BrandC<typeof Common_ffba_.Phone, PhoneBrand>;
export const Phone: PhoneC = t.brand(
  Common_ffba_.Phone,
  (x): x is t.Branded<Common_ffba_.Phone, PhoneBrand> => true,
  'Phone',
);
export type PhoneBrand = {
  readonly Phone: unique symbol;
};

// Email
// Rough validation of a valid e-mail address
export type Email = t.Branded<Common_ffba_.Email, EmailBrand>;
export type EmailC = t.BrandC<typeof Common_ffba_.Email, EmailBrand>;
export const Email: EmailC = t.brand(
  Common_ffba_.Email,
  (x): x is t.Branded<Common_ffba_.Email, EmailBrand> => true,
  'Email',
);
export type EmailBrand = {
  readonly Email: unique symbol;
};

// Address
// Street address (and optional number), http://www.bitboost.com/ref/international-address-formats.html
export type Address = t.Branded<string, AddressBrand>;
export type AddressC = t.BrandC<t.StringC, AddressBrand>;
export const Address: AddressC = t.brand(
  t.string,
  (x): x is t.Branded<string, AddressBrand> => typeof x !== 'string' || x.length >= 2,
  'Address',
);
export type AddressBrand = {
  readonly Address: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(Address)).decodeSync(examplesAddress) // => examplesAddress */
export const examplesAddress: NonEmptyArray<Address> = [
  'Pohjoiskaari 29 A 2',
  'Pohjoiskaari 29 A 2, 00200, Helsinki, Finland',
  'ŸÖŸÉÿ©',
  '5-2 4-2 „Çø„Ç§„É†„Ç∫„Çπ„ÇØ„Ç®„Ç¢„Éì„É´',
  '–ö—Ä–∞—Å–Ω–∞—è –ü–ª–æ—â–∞–¥—å',
] as unknown as NonEmptyArray<Address>;
// NEGATIVE Test Case: single ascii character
/** require('io-ts-validator').validator(Address).decodeEither("a")._tag // => 'Left' */

// CountryName
// Alphabetic country name
export type CountryName = t.Branded<string, CountryNameBrand>;
export type CountryNameC = t.BrandC<t.StringC, CountryNameBrand>;
export const CountryName: CountryNameC = t.brand(
  t.string,
  (x): x is t.Branded<string, CountryNameBrand> =>
    (typeof x !== 'string' || x.match(RegExp("^(?:\\p{L}|\\s|')+$", 'u')) !== null) &&
    (typeof x !== 'string' || x.length <= 64),
  'CountryName',
);
export type CountryNameBrand = {
  readonly CountryName: unique symbol;
};

// Success
