/*

undefined
Metadata for multi-modal route search results

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import * as t from 'io-ts';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export type DefinedC = {} & DefinedType;
export const Defined: DefinedC = new DefinedType();

export const schemaId =
  'https://schemas.maas.global/core/multimodal-routes-metadata.json';

// RoutesConfigModesSpec
// Route planner query mode
export type RoutesConfigModesSpec = t.Branded<
  {
    modeId?: string;
    label?: string;
    modes?: Array<
      string &
        ('TRANSIT' | 'TAXI' | 'CAR' | 'WALK' | 'BICYCLE' | 'BICYCLE_RENT' | 'SCOOTER')
    >;
  } & {
    modeId: Defined;
    label: Defined;
    modes: Defined;
  },
  RoutesConfigModesSpecBrand
>;
export type RoutesConfigModesSpecC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        modeId: t.StringC;
        label: t.StringC;
        modes: t.ArrayC<
          t.IntersectionC<
            [
              t.StringC,
              t.UnionC<
                [
                  t.LiteralC<'TRANSIT'>,
                  t.LiteralC<'TAXI'>,
                  t.LiteralC<'CAR'>,
                  t.LiteralC<'WALK'>,
                  t.LiteralC<'BICYCLE'>,
                  t.LiteralC<'BICYCLE_RENT'>,
                  t.LiteralC<'SCOOTER'>,
                ]
              >,
            ]
          >
        >;
      }>,
      t.TypeC<{
        modeId: typeof Defined;
        label: typeof Defined;
        modes: typeof Defined;
      }>,
    ]
  >,
  RoutesConfigModesSpecBrand
>;
export const RoutesConfigModesSpec: RoutesConfigModesSpecC = t.brand(
  t.intersection([
    t.partial({
      modeId: t.string,
      label: t.string,
      modes: t.array(
        t.intersection([
          t.string,
          t.union([
            t.literal('TRANSIT'),
            t.literal('TAXI'),
            t.literal('CAR'),
            t.literal('WALK'),
            t.literal('BICYCLE'),
            t.literal('BICYCLE_RENT'),
            t.literal('SCOOTER'),
          ]),
        ]),
      ),
    }),
    t.type({
      modeId: Defined,
      label: Defined,
      modes: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      modeId?: string;
      label?: string;
      modes?: Array<
        string &
          ('TRANSIT' | 'TAXI' | 'CAR' | 'WALK' | 'BICYCLE' | 'BICYCLE_RENT' | 'SCOOTER')
      >;
    } & {
      modeId: Defined;
      label: Defined;
      modes: Defined;
    },
    RoutesConfigModesSpecBrand
  > => true,
  'RoutesConfigModesSpec',
);
export type RoutesConfigModesSpecBrand = {
  readonly RoutesConfigModesSpec: unique symbol;
};

// MultimodalRoutesMetadata
// The default export. More information at the top.
export type MultimodalRoutesMetadata = t.Branded<
  {
    availableModes?: Array<RoutesConfigModesSpec>;
    availableAccessibilityFilter?: boolean;
  } & {
    availableModes: Defined;
    availableAccessibilityFilter: Defined;
  },
  MultimodalRoutesMetadataBrand
>;
export type MultimodalRoutesMetadataC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        availableModes: t.ArrayC<typeof RoutesConfigModesSpec>;
        availableAccessibilityFilter: t.BooleanC;
      }>,
      t.TypeC<{
        availableModes: typeof Defined;
        availableAccessibilityFilter: typeof Defined;
      }>,
    ]
  >,
  MultimodalRoutesMetadataBrand
>;
export const MultimodalRoutesMetadata: MultimodalRoutesMetadataC = t.brand(
  t.intersection([
    t.partial({
      availableModes: t.array(RoutesConfigModesSpec),
      availableAccessibilityFilter: t.boolean,
    }),
    t.type({
      availableModes: Defined,
      availableAccessibilityFilter: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      availableModes?: Array<RoutesConfigModesSpec>;
      availableAccessibilityFilter?: boolean;
    } & {
      availableModes: Defined;
      availableAccessibilityFilter: Defined;
    },
    MultimodalRoutesMetadataBrand
  > => true,
  'MultimodalRoutesMetadata',
);
export type MultimodalRoutesMetadataBrand = {
  readonly MultimodalRoutesMetadata: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(MultimodalRoutesMetadata)).decodeSync(examplesMultimodalRoutesMetadata) // => examplesMultimodalRoutesMetadata */
export const examplesMultimodalRoutesMetadata: NonEmptyArray<MultimodalRoutesMetadata> = [
  {
    availableAccessibilityFilter: true,
    availableModes: [
      { modeId: 'TRANSIT', label: 'Transit', modes: ['TRANSIT'] },
      {
        modeId: 'TRANSIT__SCOOTER',
        label: 'Transit and Scooter',
        modes: ['TRANSIT', 'SCOOTER'],
      },
      {
        modeId: 'TRANSIT__BICYCLE_RENT',
        label: 'Transit and Bicycle Rent',
        modes: ['TRANSIT', 'BICYCLE_RENT'],
      },
      { modeId: 'TAXI', label: 'Taxi', modes: ['TAXI'] },
    ],
  },
] as unknown as NonEmptyArray<MultimodalRoutesMetadata>;

export default MultimodalRoutesMetadata;

// Success
