/*

undefined
Metadata for multi-modal route search results

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import * as t from 'io-ts';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

import * as Place_de2d_ from './components/place';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export type DefinedC = {} & DefinedType;
export const Defined: DefinedC = new DefinedType();

export const schemaId =
  'https://schemas.maas.global/core/multimodal-routes-metadata.json';

// RoutesConfigModesSpec
// Route planner query mode
export type RoutesConfigModesSpec = t.Branded<
  {
    modeId?: string;
    modes?: Array<
      string &
        (
          | 'TRANSIT'
          | 'TAXI'
          | 'CAR'
          | 'WALK'
          | 'BICYCLE'
          | 'BICYCLE_RENT'
          | 'SCOOTER_RENT'
        )
    >;
  } & {
    modeId: Defined;
    modes: Defined;
  },
  RoutesConfigModesSpecBrand
>;
export type RoutesConfigModesSpecC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        modeId: t.StringC;
        modes: t.ArrayC<
          t.IntersectionC<
            [
              t.StringC,
              t.UnionC<
                [
                  t.LiteralC<'TRANSIT'>,
                  t.LiteralC<'TAXI'>,
                  t.LiteralC<'CAR'>,
                  t.LiteralC<'WALK'>,
                  t.LiteralC<'BICYCLE'>,
                  t.LiteralC<'BICYCLE_RENT'>,
                  t.LiteralC<'SCOOTER_RENT'>,
                ]
              >,
            ]
          >
        >;
      }>,
      t.TypeC<{
        modeId: typeof Defined;
        modes: typeof Defined;
      }>,
    ]
  >,
  RoutesConfigModesSpecBrand
>;
export const RoutesConfigModesSpec: RoutesConfigModesSpecC = t.brand(
  t.intersection([
    t.partial({
      modeId: t.string,
      modes: t.array(
        t.intersection([
          t.string,
          t.union([
            t.literal('TRANSIT'),
            t.literal('TAXI'),
            t.literal('CAR'),
            t.literal('WALK'),
            t.literal('BICYCLE'),
            t.literal('BICYCLE_RENT'),
            t.literal('SCOOTER_RENT'),
          ]),
        ]),
      ),
    }),
    t.type({
      modeId: Defined,
      modes: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      modeId?: string;
      modes?: Array<
        string &
          (
            | 'TRANSIT'
            | 'TAXI'
            | 'CAR'
            | 'WALK'
            | 'BICYCLE'
            | 'BICYCLE_RENT'
            | 'SCOOTER_RENT'
          )
      >;
    } & {
      modeId: Defined;
      modes: Defined;
    },
    RoutesConfigModesSpecBrand
  > => true,
  'RoutesConfigModesSpec',
);
export type RoutesConfigModesSpecBrand = {
  readonly RoutesConfigModesSpec: unique symbol;
};

// MultimodalRoutesMetadata
// The default export. More information at the top.
export type MultimodalRoutesMetadata = t.Branded<
  {
    location?: Place_de2d_.Place;
    availableModes?: Array<RoutesConfigModesSpec>;
    availableAccessibilityFilter?: boolean;
  } & {
    availableModes: Defined;
    availableAccessibilityFilter: Defined;
  },
  MultimodalRoutesMetadataBrand
>;
export type MultimodalRoutesMetadataC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        location: typeof Place_de2d_.Place;
        availableModes: t.ArrayC<typeof RoutesConfigModesSpec>;
        availableAccessibilityFilter: t.BooleanC;
      }>,
      t.TypeC<{
        availableModes: typeof Defined;
        availableAccessibilityFilter: typeof Defined;
      }>,
    ]
  >,
  MultimodalRoutesMetadataBrand
>;
export const MultimodalRoutesMetadata: MultimodalRoutesMetadataC = t.brand(
  t.intersection([
    t.partial({
      location: Place_de2d_.Place,
      availableModes: t.array(RoutesConfigModesSpec),
      availableAccessibilityFilter: t.boolean,
    }),
    t.type({
      availableModes: Defined,
      availableAccessibilityFilter: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      location?: Place_de2d_.Place;
      availableModes?: Array<RoutesConfigModesSpec>;
      availableAccessibilityFilter?: boolean;
    } & {
      availableModes: Defined;
      availableAccessibilityFilter: Defined;
    },
    MultimodalRoutesMetadataBrand
  > => true,
  'MultimodalRoutesMetadata',
);
export type MultimodalRoutesMetadataBrand = {
  readonly MultimodalRoutesMetadata: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(MultimodalRoutesMetadata)).decodeSync(examplesMultimodalRoutesMetadata) // => examplesMultimodalRoutesMetadata */
export const examplesMultimodalRoutesMetadata: NonEmptyArray<MultimodalRoutesMetadata> = [
  {
    location: { lat: 35.5907257, lon: 139.6791986 },
    availableAccessibilityFilter: true,
    availableModes: [
      { modeId: 'TRANSIT', modes: ['TRANSIT'] },
      { modeId: 'TRANSIT__SCOOTER_RENT', modes: ['TRANSIT', 'SCOOTER_RENT'] },
      { modeId: 'TRANSIT__BICYCLE_RENT', modes: ['TRANSIT', 'BICYCLE_RENT'] },
      { modeId: 'TAXI', modes: ['TAXI'] },
    ],
  },
] as unknown as NonEmptyArray<MultimodalRoutesMetadata>;

export default MultimodalRoutesMetadata;

// Success
