/*

undefined
Configuration for multi-modal route search

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import * as t from 'io-ts';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export type DefinedC = {} & DefinedType;
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'https://schemas.maas.global/core/multimodal-routes-config.json';

// RoutesConfigModesSpec
// Route planner query mode
export type RoutesConfigModesSpec = t.Branded<
  {
    modeId?: string;
    modes?: Array<
      string &
        (
          | 'PUBLIC_TRANSIT'
          | 'TAXI'
          | 'CAR'
          | 'WALK'
          | 'BICYCLE'
          | 'BICYCLE_RENT'
          | 'SCOOTER_RENT'
        )
    >;
  } & {
    modeId: Defined;
    modes: Defined;
  },
  RoutesConfigModesSpecBrand
>;
export type RoutesConfigModesSpecC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        modeId: t.StringC;
        modes: t.ArrayC<
          t.IntersectionC<
            [
              t.StringC,
              t.UnionC<
                [
                  t.LiteralC<'PUBLIC_TRANSIT'>,
                  t.LiteralC<'TAXI'>,
                  t.LiteralC<'CAR'>,
                  t.LiteralC<'WALK'>,
                  t.LiteralC<'BICYCLE'>,
                  t.LiteralC<'BICYCLE_RENT'>,
                  t.LiteralC<'SCOOTER_RENT'>,
                ]
              >,
            ]
          >
        >;
      }>,
      t.TypeC<{
        modeId: typeof Defined;
        modes: typeof Defined;
      }>,
    ]
  >,
  RoutesConfigModesSpecBrand
>;
export const RoutesConfigModesSpec: RoutesConfigModesSpecC = t.brand(
  t.intersection([
    t.partial({
      modeId: t.string,
      modes: t.array(
        t.intersection([
          t.string,
          t.union([
            t.literal('PUBLIC_TRANSIT'),
            t.literal('TAXI'),
            t.literal('CAR'),
            t.literal('WALK'),
            t.literal('BICYCLE'),
            t.literal('BICYCLE_RENT'),
            t.literal('SCOOTER_RENT'),
          ]),
        ]),
      ),
    }),
    t.type({
      modeId: Defined,
      modes: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      modeId?: string;
      modes?: Array<
        string &
          (
            | 'PUBLIC_TRANSIT'
            | 'TAXI'
            | 'CAR'
            | 'WALK'
            | 'BICYCLE'
            | 'BICYCLE_RENT'
            | 'SCOOTER_RENT'
          )
      >;
    } & {
      modeId: Defined;
      modes: Defined;
    },
    RoutesConfigModesSpecBrand
  > => true,
  'RoutesConfigModesSpec',
);
export type RoutesConfigModesSpecBrand = {
  readonly RoutesConfigModesSpec: unique symbol;
};

// MultimodalRoutesConfig
// The default export. More information at the top.
export type MultimodalRoutesConfig = t.Branded<
  {
    availableModes?: Array<RoutesConfigModesSpec>;
    availableAccessibilityFilter?: boolean;
  } & {
    availableModes: Defined;
    availableAccessibilityFilter: Defined;
  },
  MultimodalRoutesConfigBrand
>;
export type MultimodalRoutesConfigC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        availableModes: t.ArrayC<typeof RoutesConfigModesSpec>;
        availableAccessibilityFilter: t.BooleanC;
      }>,
      t.TypeC<{
        availableModes: typeof Defined;
        availableAccessibilityFilter: typeof Defined;
      }>,
    ]
  >,
  MultimodalRoutesConfigBrand
>;
export const MultimodalRoutesConfig: MultimodalRoutesConfigC = t.brand(
  t.intersection([
    t.partial({
      availableModes: t.array(RoutesConfigModesSpec),
      availableAccessibilityFilter: t.boolean,
    }),
    t.type({
      availableModes: Defined,
      availableAccessibilityFilter: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      availableModes?: Array<RoutesConfigModesSpec>;
      availableAccessibilityFilter?: boolean;
    } & {
      availableModes: Defined;
      availableAccessibilityFilter: Defined;
    },
    MultimodalRoutesConfigBrand
  > => true,
  'MultimodalRoutesConfig',
);
export type MultimodalRoutesConfigBrand = {
  readonly MultimodalRoutesConfig: unique symbol;
};
/** require('io-ts-validator').validator(nonEmptyArray(MultimodalRoutesConfig)).decodeSync(examplesMultimodalRoutesConfig) // => examplesMultimodalRoutesConfig */
export const examplesMultimodalRoutesConfig: NonEmptyArray<MultimodalRoutesConfig> = [
  {
    availableAccessibilityFilter: true,
    availableModes: [
      { modeId: 'PUBLIC_TRANSIT', modes: ['PUBLIC_TRANSIT'] },
      {
        modeId: 'PUBLIC_TRANSIT__SCOOTER_RENT',
        modes: ['PUBLIC_TRANSIT', 'SCOOTER_RENT'],
      },
      {
        modeId: 'PUBLIC_TRANSIT__BICYCLE_RENT',
        modes: ['PUBLIC_TRANSIT', 'BICYCLE_RENT'],
      },
      { modeId: 'TAXI', modes: ['TAXI'] },
    ],
  },
] as unknown as NonEmptyArray<MultimodalRoutesConfig>;

export default MultimodalRoutesConfig;

// Success
