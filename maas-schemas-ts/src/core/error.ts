/*

undefined
undefined

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';
import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export interface DefinedC extends DefinedType {}
export const Defined: DefinedC = new DefinedType();

export const schemaId = 'https://schemas.maas.global/core/error.json';

// ErrorNumber
// The purpose of this remains a mystery
export type ErrorNumber = t.Branded<number, ErrorNumberBrand>;
export type ErrorNumberC = t.BrandC<t.NumberC, ErrorNumberBrand>;
export const ErrorNumber: ErrorNumberC = t.brand(
  t.number,
  (x): x is t.Branded<number, ErrorNumberBrand> =>
    (typeof x !== 'number' || x <= 999) && Number.isInteger(x),
  'ErrorNumber',
);
export interface ErrorNumberBrand {
  readonly ErrorNumber: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(ErrorNumber)).decodeSync(examplesErrorNumber) // => examplesErrorNumber */
export const examplesErrorNumber: NonEmptyArray<ErrorNumber> = ([
  500,
] as unknown) as NonEmptyArray<ErrorNumber>;

// ErrorIdentifier
// An internal error code, used for reference
export type ErrorIdentifier = t.Branded<string, ErrorIdentifierBrand>;
export type ErrorIdentifierC = t.BrandC<t.StringC, ErrorIdentifierBrand>;
export const ErrorIdentifier: ErrorIdentifierC = t.brand(
  t.string,
  (x): x is t.Branded<string, ErrorIdentifierBrand> =>
    (typeof x !== 'string' || x.length >= 1) && (typeof x !== 'string' || x.length <= 64),
  'ErrorIdentifier',
);
export interface ErrorIdentifierBrand {
  readonly ErrorIdentifier: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(ErrorIdentifier)).decodeSync(examplesErrorIdentifier) // => examplesErrorIdentifier */
export const examplesErrorIdentifier: NonEmptyArray<ErrorIdentifier> = ([
  'ERROR_TSP_UNSUPPORTED_AREA',
] as unknown) as NonEmptyArray<ErrorIdentifier>;

// ErrorCode
// The purpose of this remains a mystery
export type ErrorCode = t.Branded<ErrorNumber | ErrorIdentifier, ErrorCodeBrand>;
export type ErrorCodeC = t.BrandC<
  t.UnionC<[typeof ErrorNumber, typeof ErrorIdentifier]>,
  ErrorCodeBrand
>;
export const ErrorCode: ErrorCodeC = t.brand(
  t.union([ErrorNumber, ErrorIdentifier]),
  (x): x is t.Branded<ErrorNumber | ErrorIdentifier, ErrorCodeBrand> => true,
  'ErrorCode',
);
export interface ErrorCodeBrand {
  readonly ErrorCode: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(ErrorCode)).decodeSync(examplesErrorCode) // => examplesErrorCode */
export const examplesErrorCode: NonEmptyArray<ErrorCode> = ([
  500,
  'ERROR_TSP_UNSUPPORTED_AREA',
] as unknown) as NonEmptyArray<ErrorCode>;

// ErrorMessage
// A human readable error message (preferrably in English)
export type ErrorMessage = t.Branded<string, ErrorMessageBrand>;
export type ErrorMessageC = t.BrandC<t.StringC, ErrorMessageBrand>;
export const ErrorMessage: ErrorMessageC = t.brand(
  t.string,
  (x): x is t.Branded<string, ErrorMessageBrand> => true,
  'ErrorMessage',
);
export interface ErrorMessageBrand {
  readonly ErrorMessage: unique symbol;
}

// MaaS error reason definition
// A data structure to convey information about issues, rejections or service denial to the clients
export type Reason = t.Branded<
  {
    text?: ErrorMessage;
    errorCode?: ErrorCode;
  },
  ReasonBrand
>;
export type ReasonC = t.BrandC<
  t.PartialC<{
    text: typeof ErrorMessage;
    errorCode: typeof ErrorCode;
  }>,
  ReasonBrand
>;
export const Reason: ReasonC = t.brand(
  t.partial({
    text: ErrorMessage,
    errorCode: ErrorCode,
  }),
  (
    x,
  ): x is t.Branded<
    {
      text?: ErrorMessage;
      errorCode?: ErrorCode;
    },
    ReasonBrand
  > => true,
  'Reason',
);
export interface ReasonBrand {
  readonly Reason: unique symbol;
}
/** require('io-ts-validator').validator(nonEmptyArray(Reason)).decodeSync(examplesReason) // => examplesReason */
export const examplesReason: NonEmptyArray<Reason> = ([
  { text: 'INVALID_AUTHORIZATION', errorCode: 500 },
] as unknown) as NonEmptyArray<Reason>;

// ResponseErrorMessage
// The purpose of this remains a mystery
export type ResponseErrorMessage = t.Branded<ErrorMessage, ResponseErrorMessageBrand>;
export type ResponseErrorMessageC = t.BrandC<
  typeof ErrorMessage,
  ResponseErrorMessageBrand
>;
export const ResponseErrorMessage: ResponseErrorMessageC = t.brand(
  ErrorMessage,
  (x): x is t.Branded<ErrorMessage, ResponseErrorMessageBrand> =>
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 256),
  'ResponseErrorMessage',
);
export interface ResponseErrorMessageBrand {
  readonly ResponseErrorMessage: unique symbol;
}

// MaaS error response definition
// MaaS event response error object. An error that the service may send.
export type Response = t.Branded<
  {
    message?: ResponseErrorMessage;
    code?: ErrorCode;
  } & {
    message: Defined;
    code: Defined;
  },
  ResponseBrand
>;
export type ResponseC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        message: typeof ResponseErrorMessage;
        code: typeof ErrorCode;
      }>,
      t.TypeC<{
        message: typeof Defined;
        code: typeof Defined;
      }>,
    ]
  >,
  ResponseBrand
>;
export const Response: ResponseC = t.brand(
  t.intersection([
    t.partial({
      message: ResponseErrorMessage,
      code: ErrorCode,
    }),
    t.type({
      message: Defined,
      code: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      message?: ResponseErrorMessage;
      code?: ErrorCode;
    } & {
      message: Defined;
      code: Defined;
    },
    ResponseBrand
  > => true,
  'Response',
);
export interface ResponseBrand {
  readonly Response: unique symbol;
}

// Error
// The default export. More information at the top.
export type Error = t.Branded<unknown, ErrorBrand>;
export type ErrorC = t.BrandC<t.UnknownC, ErrorBrand>;
export const Error: ErrorC = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, ErrorBrand> => true,
  'Error',
);
export interface ErrorBrand {
  readonly Error: unique symbol;
}

export default Error;

// Success
