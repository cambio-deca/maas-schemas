/*

undefined
Response schema for itineraries-create

!!! AUTO GENERATED BY IOTSFJS REFRAIN FROM MANUAL EDITING !!!
See https://www.npmjs.com/package/io-ts-from-json-schema

*/

import * as t from 'io-ts';
import * as PaymentParameters_ from '../../../core/components/payment-parameters';
import * as Itinerary_ from '../../../core/itinerary';

export type Defined = {} | null;
export class DefinedType extends t.Type<Defined> {
  readonly _tag: 'DefinedType' = 'DefinedType';
  constructor() {
    super(
      'defined',
      (u): u is Defined => typeof u !== 'undefined',
      (u, c) => (this.is(u) ? t.success(u) : t.failure(u, c)),
      t.identity,
    );
  }
}
export interface DefinedC extends DefinedType {}
export const Defined: DefinedC = new DefinedType();

export const schemaId =
  'https://schemas.maas.global/maas-backend/itineraries/itinerary-create/response.json';

// PaymentParameter
// The purpose of this remains a mystery
export type PaymentParameter = t.Branded<
  {
    avainpay?: PaymentParameters_.AvainpayPaymentParameters;
    stripe?: PaymentParameters_.StripePaymentParameters;
  } & Record<string, unknown>,
  PaymentParameterBrand
>;
export type PaymentParameterC = t.BrandC<
  t.IntersectionC<
    [
      t.PartialC<{
        avainpay: typeof PaymentParameters_.AvainpayPaymentParameters;
        stripe: typeof PaymentParameters_.StripePaymentParameters;
      }>,
      t.RecordC<t.StringC, t.UnknownC>,
    ]
  >,
  PaymentParameterBrand
>;
export const PaymentParameter: PaymentParameterC = t.brand(
  t.intersection([
    t.partial({
      avainpay: PaymentParameters_.AvainpayPaymentParameters,
      stripe: PaymentParameters_.StripePaymentParameters,
    }),
    t.record(t.string, t.unknown),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      avainpay?: PaymentParameters_.AvainpayPaymentParameters;
      stripe?: PaymentParameters_.StripePaymentParameters;
    } & Record<string, unknown>,
    PaymentParameterBrand
  > => true,
  'PaymentParameter',
);
export interface PaymentParameterBrand {
  readonly PaymentParameter: unique symbol;
}

// PaymentParameters
// Payment parameters for asynchronous payment methods
export type PaymentParameters = t.Branded<
  PaymentParameter | Array<PaymentParameter>,
  PaymentParametersBrand
>;
export type PaymentParametersC = t.BrandC<
  t.UnionC<[typeof PaymentParameter, t.ArrayC<typeof PaymentParameter>]>,
  PaymentParametersBrand
>;
export const PaymentParameters: PaymentParametersC = t.brand(
  t.union([PaymentParameter, t.array(PaymentParameter)]),
  (
    x,
  ): x is t.Branded<PaymentParameter | Array<PaymentParameter>, PaymentParametersBrand> =>
    true,
  'PaymentParameters',
);
export interface PaymentParametersBrand {
  readonly PaymentParameters: unique symbol;
}

// Response
// The default export. More information at the top.
export type Response = t.Branded<
  | (({
      itinerary?: Itinerary_.Itinerary;
      paymentParameters?: PaymentParameters;
    } & Record<string, unknown>) & {
      itinerary: Defined;
    })
  | (({
      outward?: Itinerary_.Itinerary;
      return?: Itinerary_.Itinerary;
      paymentParameters?: PaymentParameters;
    } & Record<string, unknown>) & {
      outward: Defined;
    }),
  ResponseBrand
>;
export type ResponseC = t.BrandC<
  t.UnionC<
    [
      t.IntersectionC<
        [
          t.IntersectionC<
            [
              t.PartialC<{
                itinerary: typeof Itinerary_.Itinerary;
                paymentParameters: typeof PaymentParameters;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
          t.TypeC<{
            itinerary: typeof Defined;
          }>,
        ]
      >,
      t.IntersectionC<
        [
          t.IntersectionC<
            [
              t.PartialC<{
                outward: typeof Itinerary_.Itinerary;
                return: typeof Itinerary_.Itinerary;
                paymentParameters: typeof PaymentParameters;
              }>,
              t.RecordC<t.StringC, t.UnknownC>,
            ]
          >,
          t.TypeC<{
            outward: typeof Defined;
          }>,
        ]
      >,
    ]
  >,
  ResponseBrand
>;
export const Response: ResponseC = t.brand(
  t.union([
    t.intersection([
      t.intersection([
        t.partial({
          itinerary: Itinerary_.Itinerary,
          paymentParameters: PaymentParameters,
        }),
        t.record(t.string, t.unknown),
      ]),
      t.type({
        itinerary: Defined,
      }),
    ]),
    t.intersection([
      t.intersection([
        t.partial({
          outward: Itinerary_.Itinerary,
          return: Itinerary_.Itinerary,
          paymentParameters: PaymentParameters,
        }),
        t.record(t.string, t.unknown),
      ]),
      t.type({
        outward: Defined,
      }),
    ]),
  ]),
  (
    x,
  ): x is t.Branded<
    | (({
        itinerary?: Itinerary_.Itinerary;
        paymentParameters?: PaymentParameters;
      } & Record<string, unknown>) & {
        itinerary: Defined;
      })
    | (({
        outward?: Itinerary_.Itinerary;
        return?: Itinerary_.Itinerary;
        paymentParameters?: PaymentParameters;
      } & Record<string, unknown>) & {
        outward: Defined;
      }),
    ResponseBrand
  > => true,
  'Response',
);
export interface ResponseBrand {
  readonly Response: unique symbol;
}

export default Response;

// Success
